diff --git a/configure b/configure
index a89cfa6d95..8a69387edf 100755
--- a/configure
+++ b/configure
@@ -310,6 +310,7 @@ External library support:
   --enable-mediacodec      enable Android MediaCodec support [no]
   --enable-mediafoundation enable encoding via MediaFoundation [auto]
   --disable-metal          disable Apple Metal framework [autodetect]
+  --enable-mcm             enable Media Communication Mesh library [no]
   --enable-libmysofa       enable libmysofa, needed for sofalizer filter [no]
   --enable-openal          enable OpenAL 1.1 capture support [no]
   --enable-opencl          enable OpenCL processing [no]
@@ -1908,6 +1909,7 @@ EXTERNAL_LIBRARY_LIST="
     lv2
     mediacodec
     openal
+    mcm
     opengl
     openssl
     pocketsphinx
@@ -3594,6 +3596,8 @@ lavfi_indev_deps="avfilter"
 libcdio_indev_deps="libcdio"
 libdc1394_indev_deps="libdc1394"
 openal_indev_deps="openal"
+mcm_indev_deps="libmcm_dp"
+mcm_outdev_deps="libmcm_dp"
 opengl_outdev_deps="opengl"
 opengl_outdev_suggest="sdl2"
 oss_indev_deps_any="sys_soundcard_h"
@@ -6911,6 +6915,7 @@ enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/r
                                  die "ERROR: rkmpp requires --enable-libdrm"; }
                              }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
+enabled mcm               && check_pkg_config libmcm_dp "mcm >= 0.0.1" mcm_dp.h mcm_dequeue_buffer
 
 
 if enabled gcrypt; then
diff --git a/libavdevice/Makefile b/libavdevice/Makefile
index c30449201d..8a96586b05 100644
--- a/libavdevice/Makefile
+++ b/libavdevice/Makefile
@@ -35,6 +35,8 @@ OBJS-$(CONFIG_JACK_INDEV)                += jack.o timefilter.o
 OBJS-$(CONFIG_KMSGRAB_INDEV)             += kmsgrab.o
 OBJS-$(CONFIG_LAVFI_INDEV)               += lavfi.o
 OBJS-$(CONFIG_OPENAL_INDEV)              += openal-dec.o
+OBJS-$(CONFIG_MCM_INDEV)                 += mcm_rx.o
+OBJS-$(CONFIG_MCM_OUTDEV)                += mcm_tx.o
 OBJS-$(CONFIG_OPENGL_OUTDEV)             += opengl_enc.o
 OBJS-$(CONFIG_OSS_INDEV)                 += oss_dec.o oss.o
 OBJS-$(CONFIG_OSS_OUTDEV)                += oss_enc.o oss.o
diff --git a/libavdevice/alldevices.c b/libavdevice/alldevices.c
index 8a90fcb5d7..a3c29601ac 100644
--- a/libavdevice/alldevices.c
+++ b/libavdevice/alldevices.c
@@ -41,6 +41,8 @@ extern const AVInputFormat  ff_jack_demuxer;
 extern const AVInputFormat  ff_kmsgrab_demuxer;
 extern const AVInputFormat  ff_lavfi_demuxer;
 extern const AVInputFormat  ff_openal_demuxer;
+extern const AVInputFormat  ff_mcm_demuxer;
+extern const FFOutputFormat ff_mcm_muxer;
 extern const FFOutputFormat ff_opengl_muxer;
 extern const AVInputFormat  ff_oss_demuxer;
 extern const FFOutputFormat ff_oss_muxer;
diff --git a/libavdevice/mcm_rx.c b/libavdevice/mcm_rx.c
new file mode 100644
index 0000000000..efff99939a
--- /dev/null
+++ b/libavdevice/mcm_rx.c
@@ -0,0 +1,193 @@
+
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavformat/avformat.h"
+#include "libavformat/mux.h"
+#include <mcm_dp.h>
+#include <bsd/string.h>
+
+typedef struct McmDemuxerContext {
+    const AVClass* class; /**< Class for private options. */
+
+    int idx;
+    /* arguments */
+    char* ip_addr;
+    int port;
+    int total_frame_num;
+    char* payload_type;
+    char* protocol_type;
+    char* socket_path;
+    uint8_t is_master;
+    uint32_t interface_id;
+
+    int width;
+    int height;
+    enum AVPixelFormat pixel_format;
+    int fps;
+    uint32_t frame_size;
+
+    mcm_conn_context *rx_handle;
+    uint64_t frame_count;
+    bool first_frame;
+
+} McmDemuxerContext;
+
+static int mcm_read_header(AVFormatContext* ctx) {
+    McmDemuxerContext* s = ctx->priv_data;
+    mcm_conn_param param = { 0 };
+
+    s->frame_size = s->width * s->height * 3 / 2; //TODO:assume it's NV12
+    s->first_frame =true;
+
+     param.type = is_rx;
+
+    /* protocol type */
+
+    if (strncmp(s->protocol_type, "memif", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_MEMIF;
+        strlcpy(param.memif_interface.socket_path, s->socket_path, sizeof(param.memif_interface.socket_path));
+        param.memif_interface.is_master = s->is_master;
+        param.memif_interface.interface_id = s->interface_id;
+    } else if (strncmp(s->protocol_type, "udp", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_UDP;
+    } else if (strncmp(s->protocol_type, "tcp", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_TCP;
+    } else if (strncmp(s->protocol_type, "http", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_HTTP;
+    } else if (strncmp(s->protocol_type, "grpc", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_GRPC;
+    } else {
+        param.protocol = PROTO_AUTO;
+    }
+
+    /* payload type */
+    if (strncmp(s->payload_type, "st20", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST20_VIDEO;
+    } else if (strncmp(s->payload_type, "st22", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST22_VIDEO;
+    } else if (strncmp(s->payload_type, "st30", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST30_AUDIO;
+    } else if (strncmp(s->payload_type, "st40", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST40_ANCILLARY;
+    } else if (strncmp(s->payload_type, "rtsp", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_RTSP_VIDEO;
+    } else {
+        param.payload_type = PAYLOAD_TYPE_NONE;
+    }
+
+    switch (param.payload_type) {
+    case PAYLOAD_TYPE_ST30_AUDIO:
+        /* audio format */
+        param.payload_args.audio_args.type = AUDIO_TYPE_FRAME_LEVEL;
+        param.payload_args.audio_args.channel = 2;
+        param.payload_args.audio_args.format = AUDIO_FMT_PCM16;
+        param.payload_args.audio_args.sampling = AUDIO_SAMPLING_48K;
+        param.payload_args.audio_args.ptime = AUDIO_PTIME_1MS;
+        break;
+    case PAYLOAD_TYPE_ST40_ANCILLARY:
+        /* ancillary format */
+        param.payload_args.anc_args.format = ANC_FORMAT_CLOSED_CAPTION;
+        param.payload_args.anc_args.type = ANC_TYPE_FRAME_LEVEL;
+        param.payload_args.anc_args.fps = s->fps;
+        break;
+    case PAYLOAD_TYPE_RTSP_VIDEO:
+    case PAYLOAD_TYPE_ST20_VIDEO:
+    case PAYLOAD_TYPE_ST22_VIDEO:
+    default:
+        /* video format */
+        param.pix_fmt = PIX_FMT_YUV444M;
+        param.payload_args.video_args.width   = param.width = s->width;
+        param.payload_args.video_args.height  = param.height = s->height;
+        param.payload_args.video_args.fps     = param.fps = s->fps;
+        param.payload_args.video_args.pix_fmt = param.pix_fmt = s->pixel_format;
+        break;
+    }
+
+    strlcpy(param.remote_addr.ip, s->ip_addr, sizeof(param.remote_addr.ip));
+    strlcpy(param.local_addr.port, s->port, sizeof(param.local_addr.port));
+
+    s->rx_handle = mcm_create_connection(&param);
+    if (!s->rx_handle) {
+        //err(ctx, "%s, mcm_create_connection failed\n", __func__);
+        return AVERROR(EIO);
+    }
+    return 0;
+}
+
+static int mcm_read_packet(AVFormatContext* ctx, AVPacket* pkt) {
+    McmDemuxerContext* s = ctx->priv_data;
+    mcm_buffer* buf = NULL;
+    int timeout = -1;
+    int err = 0;
+
+    /* receive frame */
+    if (s->first_frame) {
+        /* infinity for the 1st frame. */
+        timeout = -1;
+        s->first_frame = false;
+    } else {
+        /* 1 second */
+        timeout = 1000;
+    }
+
+    buf = mcm_dequeue_buffer(s->rx_handle, timeout, &err);
+
+    if (buf == NULL) {
+        return AVERROR(EIO);
+    }
+
+    if (strncmp(s->payload_type, "rtsp", sizeof(s->payload_type)) != 0) {
+        fwrite(buf->data, s->frame_size, 1, pkt->data);
+    } else { //TODO: rtsp receiver side test code
+        fwrite(buf->data, buf->len, 1, pkt->data);
+    }
+
+    s->frame_count++;
+
+    /* enqueue buffer */
+    if (mcm_enqueue_buffer(s->rx_handle, buf) != 0) {
+        return AVERROR(EIO);
+    }
+    return 0;
+}
+
+static int mcm_read_close(AVFormatContext* ctx) {
+    McmDemuxerContext* s = ctx->priv_data;
+
+    mcm_destroy_connection(s->rx_handle);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(McmDemuxerContext, x)
+#define DEC (AV_OPT_FLAG_DECODING_PARAM)
+static const AVOption mcm_rx_options[] = {
+    {"ip_addr", "IP address", OFFSET(ip_addr), AV_OPT_TYPE_STRING, {.str = NULL}, .flags = DEC},
+    {"port", "port", OFFSET(port), AV_OPT_TYPE_INT, {.i64 = 9001}, -1, INT_MAX, DEC},
+    {"fps", "FPS", OFFSET(fps), AV_OPT_TYPE_INT, {.i64 = 30}, -1, INT_MAX, DEC},
+    {"total_frame_num", "Frame number", OFFSET(total_frame_num), AV_OPT_TYPE_INT, {.i64 = 10000}, -1, INT_MAX, DEC},
+    {"payload_type", "Payload type", OFFSET(payload_type), AV_OPT_TYPE_INT, {.str = NULL}, .flags = DEC},
+    {"protocol_type", "Protocol type", OFFSET(protocol_type), AV_OPT_TYPE_INT, {.str = "auto"}, .flags = DEC},
+    {"is_master", "Is master", OFFSET(is_master), AV_OPT_TYPE_INT, {.i64 = 1}, -1, INT_MAX, DEC},
+    {"interface_id", "interface ID", OFFSET(interface_id), AV_OPT_TYPE_INT, {.i64 = 0}, -1, INT_MAX, DEC},
+};
+
+static const AVClass mcm_demuxer_class = {
+    .class_name = "mcm demuxer",
+    .item_name = av_default_item_name,
+    .option = mcm_rx_options,
+    .version = LIBAVUTIL_VERSION_INT,
+    .category = AV_CLASS_CATEGORY_DEVICE_INPUT,
+};
+
+AVInputFormat ff_mcm_demuxer = {
+        .name = "mcm",
+        .long_name = NULL_IF_CONFIG_SMALL("Media Communication Mesh input device"),
+        .priv_data_size = sizeof(McmDemuxerContext),
+        .read_header = mcm_read_header,
+        .read_packet = mcm_read_packet,
+        .read_close = mcm_read_close,
+        .flags = AVFMT_NOFILE,
+        .extensions = "mcm",
+        .raw_codec_id = AV_CODEC_ID_RAWVIDEO,
+        .priv_class = &mcm_demuxer_class,
+};
diff --git a/libavdevice/mcm_tx.c b/libavdevice/mcm_tx.c
new file mode 100644
index 0000000000..8c89de1292
--- /dev/null
+++ b/libavdevice/mcm_tx.c
@@ -0,0 +1,174 @@
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavformat/avformat.h"
+#include "libavformat/mux.h"
+#include <mcm_dp.h>
+#include <bsd/string.h>
+
+#define DEFAULT_MEMIF_SOCKET_PATH "/run/mcm/mcm_rx_memif.sock"
+
+typedef struct McmMuxerContext {
+    const AVClass* class; /**< Class for private options. */
+
+    int idx;
+    /* arguments */
+    char* ip_addr;
+    int port;
+    int total_frame_num;
+    char* payload_type;
+    char* protocol_type;
+    char* socket_path;
+    uint8_t is_master;
+    uint32_t interface_id;
+
+    int width;
+    int height;
+    enum AVPixelFormat pixel_format;
+    int fps;
+
+    mcm_conn_context *tx_handle;
+    uint64_t frame_count
+
+} McmMuxerContext;
+
+static int mcm_write_header(AVFormatContext* ctx) {
+    McmMuxerContext* s = ctx->priv_data;
+    mcm_conn_param param = { 0 };
+
+    char socket_path[108] = DEFAULT_MEMIF_SOCKET_PATH;
+
+    param.type = is_tx;
+    param.width = s->width = ctx->streams[0]->codecpar->width;
+    param.height = s->height = ctx->streams[0]->codecpar->height;
+
+
+ if (strncmp(s->protocol_type, "memif", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_MEMIF;
+        strlcpy(param.memif_interface.socket_path, socket_path, sizeof(param.memif_interface.socket_path));
+        param.memif_interface.is_master = s->is_master;
+        param.memif_interface.interface_id = s->interface_id;
+    } else if (strncmp(s->protocol_type, "udp", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_UDP;
+    } else if (strncmp(s->protocol_type, "tcp", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_TCP;
+    } else if (strncmp(s->protocol_type, "http", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_HTTP;
+    } else if (strncmp(s->protocol_type, "grpc", sizeof(s->protocol_type)) == 0) {
+        param.protocol = PROTO_GRPC;
+    } else {
+        param.protocol = PROTO_AUTO;
+    }
+
+    /* payload type */
+    if (strncmp(s->payload_type, "st20", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST20_VIDEO;
+    } else if (strncmp(s->payload_type, "st22", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST22_VIDEO;
+    } else if (strncmp(s->payload_type, "st30", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST30_AUDIO;
+    } else if (strncmp(s->payload_type, "st40", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_ST40_ANCILLARY;
+    } else if (strncmp(s->payload_type, "rtsp", sizeof(s->payload_type)) == 0) {
+        param.payload_type = PAYLOAD_TYPE_RTSP_VIDEO;
+    } else {
+        param.payload_type = PAYLOAD_TYPE_NONE;
+    }
+
+    switch (param.payload_type) {
+        case PAYLOAD_TYPE_ST30_AUDIO:
+            /* audio format */
+            param.payload_args.audio_args.type = AUDIO_TYPE_FRAME_LEVEL;
+            param.payload_args.audio_args.channel = 2;
+            param.payload_args.audio_args.format = AUDIO_FMT_PCM16;
+            param.payload_args.audio_args.sampling = AUDIO_SAMPLING_48K;
+            param.payload_args.audio_args.ptime = AUDIO_PTIME_1MS;
+            break;
+        case PAYLOAD_TYPE_ST40_ANCILLARY:
+            /* ancillary format */
+            param.payload_args.anc_args.format = ANC_FORMAT_CLOSED_CAPTION;
+            param.payload_args.anc_args.type = ANC_TYPE_FRAME_LEVEL;
+            param.payload_args.anc_args.fps = s->fps;
+            break;
+        case PAYLOAD_TYPE_ST20_VIDEO:
+        case PAYLOAD_TYPE_ST22_VIDEO:
+        default:
+            /* video format */
+            param.payload_args.video_args.width   = param.width = s->width;
+            param.payload_args.video_args.height  = param.height = s->height;
+            param.payload_args.video_args.fps     = param.fps = s->fps;
+            param.payload_args.video_args.pix_fmt = param.pix_fmt = s->pixel_format;
+            break;
+    }
+
+    s->tx_handle = mcm_create_connection(&param);
+    if (!s->tx_handle) {
+        //err(ctx, "%s, mcm_create_connection failed\n", __func__);
+        return AVERROR(EIO);
+    }
+    return 0;
+}
+
+static int mcm_write_packet(AVFormatContext* ctx, AVPacket* pkt) {
+    McmMuxerContext* s = ctx->priv_data;
+    mcm_buffer* buf = NULL;
+
+    buf = mcm_dequeue_buffer(s->tx_handle, -1, NULL);
+    if (buf == NULL) {
+        return AVERROR(EIO);
+    }
+
+    // if (read_test_data(pkt->data, buf, s->width, s->height, s->pixel_format) < 0) {
+    //     return AVERROR(EIO);
+    // }
+
+    if (mcm_enqueue_buffer(s->tx_handle, buf) != 0) {
+        return AVERROR(EIO);
+    }
+
+    s->frame_count++;
+
+    if (s->frame_count >= s->total_frame_num) {
+        return AVERROR(EIO);
+    }
+    return 0;
+}
+
+static int mcm_write_trailer(AVFormatContext* ctx) {
+    McmMuxerContext* s = ctx->priv_data;
+
+    mcm_destroy_connection(s->tx_handle);
+    return 0;
+}
+
+#define OFFSET(x) offsetof(McmMuxerContext, x)
+#define ENC AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption mcm_tx_options[] = {
+    {"ip_addr", "IP address", OFFSET(ip_addr), AV_OPT_TYPE_STRING, {.str = NULL}, .flags = ENC},
+    {"port", "port", OFFSET(port), AV_OPT_TYPE_INT, {.i64 = 9001}, -1, INT_MAX, ENC},
+    {"fps", "FPS", OFFSET(fps), AV_OPT_TYPE_INT, {.i64 = 30}, -1, INT_MAX, ENC},
+    {"total_frame_num", "Frame number", OFFSET(total_frame_num), AV_OPT_TYPE_INT, {.i64 = 10000}, -1, INT_MAX, ENC},
+    {"payload_type", "Payload type", OFFSET(payload_type), AV_OPT_TYPE_INT, {.str = "st20"}, .flags = ENC},
+    {"protocol_type", "Protocol type", OFFSET(protocol_type), AV_OPT_TYPE_INT, {.str = "auto"}, .flags = ENC},
+    {"is_master", "Is master", OFFSET(is_master), AV_OPT_TYPE_INT, {.i64 = 1}, -1, INT_MAX, ENC},
+    {"interface_id", "interface ID", OFFSET(interface_id), AV_OPT_TYPE_INT, {.i64 = 0}, -1, INT_MAX, ENC},
+};
+
+static const AVClass mcm_muxer_class = {
+    .class_name = "mcm muxer",
+    .item_name = av_default_item_name,
+    .option = mcm_tx_options,
+    .version = LIBAVUTIL_VERSION_INT,
+    .category = AV_CLASS_CATEGORY_DEVICE_OUTPUT,
+};
+
+const FFOutputFormat ff_mcm_muxer = {
+    .p.name = "mcm",
+    .p.long_name = NULL_IF_CONFIG_SMALL("Media Communication Mesh output device"),
+    .priv_data_size = sizeof(McmMuxerContext),
+    .write_header = mcm_write_header,
+    .write_packet = mcm_write_packet,
+    .write_trailer = mcm_write_trailer,
+    .p.video_codec = AV_CODEC_ID_RAWVIDEO,
+    .p.flags = AVFMT_NOFILE,
+    .p.priv_class = &mcm_muxer_class,
+};
